from PyQt5.QtCore import Qt, pyqtSignal, pyqtSlot, QSortFilterProxyModel
from PyQt5.QtWidgets import QWidget, QTableView, QAbstractItemView, QVBoxLayout, QHeaderView, QMenu, QDataWidgetMapper
from PyQt5.QtSql import QSqlTableModel
from delegates import DataMapperDelegate

from database import *


class ProwlerSqlWidget(QWidget):
    """Base class for all SQL-dependant widgets. Populates a QSqlTableModel from a given source."""

    def __init__(self, parent=None):
        super(ProwlerSqlWidget, self).__init__(parent=parent)

        self.dbsession = Session()
        self.source = None

        # Set up the main model
        self.model = QSqlTableModel(self)
        self.model.setEditStrategy(QSqlTableModel.OnManualSubmit)

    def set_source(self, source):
        """Calls generate_query() with the given source, and populates the model with the resulting query."""
        self.source = source

        # Custom query is generated by the subclass
        sa_query = self.generate_query(source)

        # Translate the SQLAlchemy query to a QSqlQuery
        qt_query = saquery_to_qtquery(sa_query)
        qt_query.exec_()

        # Clear and re-populate the model
        self.model.clear()
        self.model.setQuery(qt_query)
        self.model.select()

    def generate_query(self, source):
        """Generate a query, based on source, used to populate the main table. Must include an 'id' column for
        selection behaviours to work.
        """

    def reload(self):
        """Repopulates the model."""
        self.set_source(self.source)


class ProwlerTableWidget(ProwlerSqlWidget):
    """Base class for all table-based SQL widgets. Takes care of selection management and context menu."""

    # Notifier for selection changes in the main table. Use the selected_ids property to access the selection.
    selection_changed = pyqtSignal()
    double_clicked = pyqtSignal()

    def __init__(self, parent=None):
        super(ProwlerTableWidget, self).__init__(parent=parent)
        self.context_menu_actions = []

        # Set up the model and table
        sort_model = QSortFilterProxyModel(self)
        sort_model.setSourceModel(self.model)

        self.table = QTableView(self)
        self.table.setModel(sort_model)
        self.table.setSortingEnabled(True)

        # Extended row selection by default
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.table.selectionModel().selectionChanged.connect(self.selection_changed)

        # Editing disabled by default
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)

        # Enable custom context menu
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.context_menu)

        # Set default header behaviour
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)

        # Add the table to a layout, add the layout to the widget
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        layout.addWidget(self.table)
        self.setLayout(layout)

        # Connect the double_clicked signal
        self.table.doubleClicked.connect(self.double_clicked)

    @property
    def selected_ids(self):
        """Return the values in the 'id' column for each selected row."""
        id_idx_list = self.table.selectionModel().selectedRows(self.model.fieldIndex('id'))
        return [idx.data() for idx in id_idx_list]

    def get_selected_id(self):
        """Return the last id in self.selected_ids, or None."""
        return self.selected_ids[-1] if self.selected_ids else None

    def context_menu(self, point):
        """Generate a popup menu from the actions in self.context_menu_actions."""
        menu = QMenu(self)
        menu.addActions(self.context_menu_actions)

        point = self.table.viewport().mapToGlobal(point)
        menu.popup(point)

    def add_context_action(self, action):
        """Add an action to the context menu."""
        self.context_menu_actions.append(action)

    def add_context_actions(self, actions):
        """Adds all actions in an iterable."""
        self.context_menu_actions.extend(actions)

    def remove_context_action(self, action):
        """Remove an action from the context menu."""
        self.context_menu_actions.remove(action)

    def hasFocus(self):
        return self.table.hasFocus()


class ProductDetailsWidget(ProwlerSqlWidget):
    """Base class for the AmzProductDetailsWidget and VndProductDetailsWidget classes. Doesn't have it's own
    UI, but depends on certain UI elements (like self.titleLine) to be available.
    """

    def __init__(self, parent=None):
        super(ProductDetailsWidget, self).__init__(parent=parent)
        self.setupUi(self)

        # Populate the columns
        self.set_source(None)

        # Set up the data widget mapper
        self.mapper = QDataWidgetMapper(self)
        self.mapper.setModel(self.model)
        self.mapper.setItemDelegate(DataMapperDelegate(self))
        self.mapper.currentIndexChanged.connect(self.rewind_lines)

        self.mapper.addMapping(self.titleLine, self.model.fieldIndex('title'))
        self.mapper.addMapping(self.brandLine, self.model.fieldIndex('brand'))
        self.mapper.addMapping(self.modelLine, self.model.fieldIndex('model'))
        self.mapper.addMapping(self.skuLine, self.model.fieldIndex('sku'))
        self.mapper.addMapping(self.upcLine, self.model.fieldIndex('upc'))
        self.mapper.addMapping(self.priceBox, self.model.fieldIndex('price'))
        self.mapper.addMapping(self.quantityBox, self.model.fieldIndex('quantity'))

        self.model.modelReset.connect(self.mapper.toFirst)

    def rewind_lines(self):
        """Reset text lines to home position."""
        self.titleLine.home(False)
        self.brandLine.home(False)
        self.modelLine.home(False)

    def generate_query(self, source):
        """Assume that source is either a VendorListing or AmazonListing object."""
        listing_id = getattr(source, 'id', None)

        # Note that this 'defaults' to show AmazonListings. This is OK for the data widget mapper,
        # since AmazonListing contains all the fields that VendorListing does.
        listing_type = VendorListing if isinstance(source, VendorListing) else AmazonListing

        return self.dbsession.query(listing_type).filter_by(id=listing_id)


